/* 
 * File:   Encoder.h
 * Author:  Qingyi Wang
 * Created on October 22, 2021
 * 
 * Description:
 * - Configure external interrupt to handle pulse counting.
 * - Configure timer 1 overflow to measure the motor speed every 0.1s.
 * - Count the number pulses generated by the encoder.
 * - Calculated the speed of motor by pulse counting.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "p18f452.h"
#include "Encoder.h"

// used to store the number of pulses generated by the encoder
int Encoder_1_A;
int Encoder_1_B;
int Encoder_2_A;
int Encoder_2_B;

// used to store the speed of the motor in RPM
double Motor_1;
double Motor_2;

// enable PORTB<2:0> and PORTB<4> for external interrupt
void Enable_PortB(void)
{
    // set PORTB<2:0> and <4> as input
    TRISBbits.RB0 = 1;    // RB0 --> Motor 1 Encoder Channel A
    TRISBbits.RB1 = 1;    // RB1 --> Motor 1 Encoder Channel B
    TRISBbits.RB2 = 1;    // RB2 --> Motor 2 Encoder Channel A
    TRISBbits.RB4 = 1;    // RB4 --> Motor 2 Encoder Channel B
}

// enable Timer1 and preload the sampling time interval into TMR1
// If the TMR1 overflows, the Timer1 interrupt will be triggered,
// while four encoder counting variables should be reset.
void Timer1_Setup(void)
{
    T1CONbits.RD16 = 1;     // configure Timer1 as a 16-bit timer/counter
    //T1CONbits.TMR1ON = 1;   // enable Timer1
    T1CONbits.T1CKPS1 = 1;  // 1:8 prescale value
    T1CONbits.T1CKPS0 = 1;
    
    // expect the sampling period is 0.1s
    // TMR1<H:L> = Resolution - [(T*Fosc)/(4*Prescale)]
    //           = 65535 - [(1*10M)/(4*8)] = 34285 in decimal
    // TMR1<H:L> = 1000 0101 1110 1101 in binary
    TMR1H = 0b10000101;
    TMR1L = 0b11101101;
}

// configure PORTB<2:0> and PORTB<4> for external interrupt
void Encoder_Interrupt_Setup(void)
{
    Disable_Interrupt();
    
    RCONbits.IPEN = 1;      //enable priority 
    
    INTCON2bits.RBPU = 1;   // disable all PORTB pull-up resistors
    
    // external interrupt on PORTB<0>/INT0
    // NOTICE: No priority bit associated with INT0 (a high priority interrupt source)
    INTCONbits.INT0IE = 1;  // enable the INT0 external interrupt
    INTCONbits.INT0IF = 0;  // clear INT0 external interrupt flag bit
    
    // external interrupt on PORTB<1>/INT1
    INTCON3bits.INT1IE = 1; // enable the INT1 external interrupt
    INTCON3bits.INT1IF = 0; // clear INT1 external interrupt flag bit
    INTCON3bits.INT1IP = 1; // set INT1 to high priority 
    
    // external interrupt on PORTB<2>/INT2
    INTCON3bits.INT2IE = 1; // enable the INT2 external interrupt
    INTCON3bits.INT2IF = 0; // clear INT2 external interrupt flag bit
    INTCON3bits.INT2IP = 1; // set INT2 to high priority 
    
    // interrupt-on-change on PORTB<4>
    INTCONbits.RBIE = 1;    // enable PORTB<4> change interrupt
    INTCONbits.RBIF = 0;    // clear PORT<4> interrupt flag bit 
    INTCON2bits.RBIP = 1;   // set PORTB<4> to high priority
    
    // INT0, INT1, and INT2 external interrupts will be triggered on the rising edge
    INTCON2bits.INTEDG0 = 1;
    INTCON2bits.INTEDG1 = 1;
    INTCON2bits.INTEDG2 = 1;
    
    Enable_Interrupt();
}

void Enable_Interrupt(void)
{
    INTCONbits.GIEH = 1;    // enable high priority interrupt
}

void Disable_Interrupt(void)
{
    INTCONbits.GIEH = 0;    //disable interrupt 
    INTCONbits.GIEL = 0;
}

// count the number of pulses per channel
void Count_Pulse_Per_Channel(int Encoder_Channel)
{
    switch(Encoder_Channel)
    {
        case 1:
            Encoder_1_A++;
            break;
        case 2:
            Encoder_1_B++;
            break;
        case 3:
            Encoder_2_A++;
            break;
        case 4:
            Encoder_2_B++;
            break;
        default:
            break;
    }
}

// calculate the speed of each motor
double Get_RPM(int Motor_Number)
{
    double RPM = 0;
    int Number_of_Pulses = 0;
    int Pulses_per_Rotation = 16;
    double Sampling_Period = 0.1;
    double scale = 131.25;
    
    switch(Motor_Number)
    {
        case 1:
            Number_of_Pulses = Encoder_1_A;
            //Number_of_Pulses = Encoder_1_A + Encoder_1_B;
            break;
        case 2:
            Number_of_Pulses = Encoder_2_A;
            //Number_of_Pulses = Encoder_2_A + Encoder_2_B;
            break;
        default:
            break;
    }
    
    RPM = 60*(Number_of_Pulses/(Pulses_per_Rotation*Sampling_Period*scale));
    return RPM;
}

// reset four counter variables
void Reset_Counter(void)
{
    Encoder_1_A = 0;
    Encoder_1_B = 0;
    Encoder_2_A = 0;
    Encoder_2_B = 0;
}

// handle the TMR1 overflows
void TMR1_Overflow(void)
{
    T1CONbits.TMR1ON = 1;   // enable Timer1
    
    while(PIR1bits.TMR1IF == 0);    // wait until the TMR1 overflow
    
    Motor_1 = Get_RPM(1);   // get Motor 1 speed
    Motor_2 = Get_RPM(2);   // get Motor 2 speed
    
    PIR1bits.TMR1IF = 0;    // clear TMR1 overflow interrupt flag bit 
    T1CONbits.TMR1ON = 0;   // disable Timer1
    
    Reset_Counter();
    
    TMR1H = 0b10000101;
    TMR1L = 0b11101101;
}